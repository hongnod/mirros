#include "lmfs.h"
#include "device_drive.h"
#include"lmfs_config.h"


/******************************************************

此系统可能需要比较大的堆栈
建议要大于512b
系统必须有动态内存管理函数。
实现了

malloc

和
free
**************************************************/


/*****************************************
、、、、、、、
MBR
，，，，，，

  ，，，，，
  超级块
  ，，，，，

  ，，，，，，，，
	节点表
  ，，，，，，，

  ，，，，，，
	空闲块表
  ，，，，，，

  ，，，，，，，，，，
	数据区
  ，，，，，，，，，，

****************************************/




static unsigned char MBR[512]=
{
0x33,0xC0,0x8E,0xD0,0xBC,0x00,0x7C,0xFB,0x50,0x07,0x50,0x1F,0xFC,0xBE,0x1B,0x7c,
0xBF,0x1B,0x06,0x50,0x57,0xB9,0xE5,0x01,0xF3,0xA4,0xCB,0xBE,0xBE,0x07,0xB1,0x04,
0x38,0x2C,0x7C,0x09,0x75,0x15,0x83,0xC6,0x10,0xE2,0xF5,0xCD,0x18,0x8B,0x14,0x8b,
0xEE,0x83,0xC6,0x10,0x49,0x74,0x16,0x38,0x2C,0x74,0xF6,0xBE,0x10,0x07,0x4E,0xac,
0x3C,0x00,0x74,0xFA,0xBB,0x07,0x00,0xB4,0x0E,0xCD,0x10,0xEB,0xF2,0x89,0x46,0x25,
0x96,0x8A,0x46,0x04,0xB4,0x06,0x3C,0x0E,0x74,0x11,0xB4,0x0B,0x3C,0x0C,0x74,0x05,
0x3A,0xC4,0x75,0x2B,0x40,0xC6,0x46,0x25,0x06,0x75,0x24,0xBB,0xAA,0x55,0x50,0xB4,
0x41,0xCD,0x13,0x58,0x72,0x16,0x81,0xFB,0x55,0xAA,0x75,0x10,0xF6,0xC1,0x01,0x74,
0x0B,0x8A,0xE0,0x88,0x56,0x24,0xC7,0x06,0xA1,0x06,0xEB,0x1E,0x88,0x66,0x04,0xBF,
0x0A,0x00,0xB8,0x01,0x02,0x8B,0xDC,0x33,0xC9,0x83,0xFF,0x05,0x7F,0x03,0x8B,0x4E,
0x25,0x03,0x4E,0x02,0xCD,0x13,0x72,0x29,0xBE,0x2D,0x07,0x81,0x3E,0xFE,0x7D,0x55,
0xAA,0x74,0x5A,0x83,0xEF,0x05,0x7F,0xDA,0x85,0xF6,0x75,0x83,0xBE,0x1A,0x07,0xEB,
0x8A,0x98,0x91,0x52,0x99,0x03,0x46,0x08,0x13,0x56,0x0A,0xE8,0x12,0x00,0x5A,0xEB,
0xD5,0x4F,0x74,0xE4,0x33,0xC0,0xCD,0x13,0xEB,0xB8,0x00,0x00,0x80,0x49,0x12,0x00,
0x56,0x33,0xF6,0x56,0x56,0x52,0x50,0x06,0x53,0x51,0xBE,0x10,0x00,0x56,0x8B,0xF4,
0x50,0x52,0xB8,0x00,0x42,0x8A,0x56,0x24,0xCD,0x13,0x5A,0x58,0x64,0x10,0x72,0x00,
0x0A,0x40,0x75,0x01,0x42,0x80,0xC7,0x02,0xE2,0xF7,0xF8,0x5E,0xC3,0xEB,0x74,0xB7,
0xD6,0xC7,0xF8,0xB1,0xED,0xCE,0xDE,0xD0,0xA7,0x00,0xBC,0xD3,0xD4,0xD8,0xB2,0xD9,
0xD7,0xF7,0xCF,0xB5,0xCD,0xB3,0xCA,0xB1,0xB3,0xF6,0xB4,0xED,0x00,0x4D,0x69,0x73,
0x73,0x69,0x6E,0x67,0x20,0x6F,0x70,0x65,0x72,0x61,0x74,0x69,0x6E,0x67,0x20,0x73,
0x79,0x73,0x74,0x65,0x6D,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x8B,0xFC,0x1E,0x57,0x8B,0xF5,0xCB,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x86,0xD8,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x55,0xAA,
};		//在LMFS中不会用到，所有信息都来自superblock。但也会填入重要信息。

//static unsigned char [512]={0};	//要写入的超级快信息。


FSBOOL init_fmls(void)			//初始化文件系统。
{
	
	PNODE_INFO tmp;
	get_device_drive();
	read_sector(1,_super_block_buffer);
	if(_super_block_buffer[37] != 0x88)
	{
#ifdef LMFS_AUTO_FORMAT
		if(format_device() != SUCCESS) return UNSUCCESS;			//格式化设备，用到的参数是设备的驱动程序。可选进行配置。
#endif
	}
	/*****************************
	 加载空闲列表块，和超级快，以及当前目录块的节点信息。
	********************************/
	read_sector(1,_super_block_buffer);				//要进行修改，增强移植性。

	sp=(PSUPER_BLOCK)_super_block_buffer;

	read_sector(sp->node_section_first_sector,_write_buffer);		//获取根目录和当前目录的节点信息并存储在全局变量中。
	tmp=(PNODE_INFO)_write_buffer;
	root_dir_node=*tmp;
	cur_dir_node=root_dir_node;

	//初始化空闲块的指针和缓冲。
	read_sector(sp->free_block_cur_sector,_free_block_buffer);
	free_pos=(FSU32 *)(&_free_block_buffer[sp->free_block_cur_pos * sizeof(FSU32)]);
	//初始化了空闲列表区

	return 1;
}

FSBOOL format_device(void)			//格式化介质。
{
	PMBR_PARTION ptr_mbr;

	ptr_mbr=(PMBR_PARTION)(&MBR[446]);			//更新启动扇区信息。
	ptr_mbr->begin_head=0;
	ptr_mbr->begin_sector=PARTION_FIRST_SECTOR;				//格式化的时候可以传入参数计算，不一定为0；
	ptr_mbr->begin_ab_sector=PARTION_FIRST_SECTOR;
	ptr_mbr->boot_ind=0x80;
	ptr_mbr->end_head=0;
	ptr_mbr->end_sector=sd.disk_total_sector-1+PARTION_FIRST_SECTOR;
	ptr_mbr->partion_type=0x88;
	ptr_mbr->total_sector=sd.disk_total_sector;

	write_sector(0,MBR);

	write_super_block_data();

	return SUCCESS;
}

void write_super_block_data(void)		//写入超级块信息。
{
	PSUPER_BLOCK ptr;
	FSU32 a,b,x;
	PNODE_INFO root;

	//还要添加初始化根目录的代码。

	x=(sd.disk_total_sector*sd.sector_per_size)/(BLOCK_SIZE+NODE_INFO_SIZE+sizeof(FSU32))-1;			//总共可用的数据块。
	a=(x*NODE_INFO_SIZE)/SECTOR_PER_SIZE+1;							//节点表占用的扇区数。
	b=(x*sizeof(FSU32))/SECTOR_PER_SIZE+1;							//空闲块暂用的扇区数

	ptr=(PSUPER_BLOCK)_super_block_buffer;
	ptr->block_per_sector=BLOCK_SIZE/SECTOR_PER_SIZE;
	ptr->device_sector_size=SECTOR_PER_SIZE;
	ptr->device_total_sector=sd.disk_total_sector;
	ptr->fs_fisrt_sector=PARTION_FIRST_SECTOR;
	ptr->fs_name[0]='L';
	ptr->fs_name[1]='M';
	ptr->fs_name[2]='F';
	ptr->fs_name[3]='S';
	ptr->fs_name[4]=0;
	ptr->fs_name[5]=0;
	ptr->fs_name[6]=0;
	ptr->fs_end_sector=sd.disk_total_sector-1+PARTION_FIRST_SECTOR;
	ptr->fs_type=0x88;
	ptr->fs_version=1;
	ptr->jmp_code=0;
	ptr->media_type=0x01;
	ptr->data_section_first_block=0;
	ptr->data_section_first_sector=2+a+b+PARTION_FIRST_SECTOR;
	ptr->data_section_total_sector=x*(BLOCK_SIZE/SECTOR_PER_SIZE);
	ptr->free_block_cur_sector=2+a+PARTION_FIRST_SECTOR;
	ptr->free_block_cur_pos=0;
	ptr->free_block_first_sector=2+a+PARTION_FIRST_SECTOR;
	ptr->free_section_total_sector=b;
	ptr->node_section_first_sector=2+PARTION_FIRST_SECTOR;
	ptr->node_section_total_sector=a;
	ptr->super_block_first_sector=1+PARTION_FIRST_SECTOR;
	ptr->super_block_size=512;

	init_free_section(2+a+PARTION_FIRST_SECTOR,b+PARTION_FIRST_SECTOR,x);

	init_node_section(2+PARTION_FIRST_SECTOR,a+PARTION_FIRST_SECTOR,x);
	//初始化根目录。
	root=(PNODE_INFO)_write_buffer;
	root->block_alloc=1;			//分配了第0块给根目录。
	root->file_amount=0;
	root->file_attrib=READ_WRITE|DIR;
	root->file_size=BLOCK_SIZE;				// 记录目录的总共大小。
	root->file_type=DIR;
	root->last_modify_time=TIME;
	root->level0_block[0]=0;
	root->pos_in_sector=0;
	root->sector=2+PARTION_FIRST_SECTOR;
	root->unused=0;
	root->used=1;
	write_sector(2+PARTION_FIRST_SECTOR,_write_buffer);

	write_sector(1+PARTION_FIRST_SECTOR,_super_block_buffer);
}

void init_free_section(FSU32 start_sector,FSU32 free_block,FSU32 total_data_sector)		//初始化空闲块表。
{
	FSU32 *ptr;
	FSU32 i,j,y=1;
	for(i=0;i<free_block;i++)
	{
		for(j=0;j<BLOCK_PER_BLOCK;j++)
		{
			ptr=(FSU32 *)(&_write_buffer[j*sizeof(FSU32)]);
			if(y<total_data_sector)
			{
				*ptr=y;
				y++;
			}
			else
			{
				*ptr=0;
			}
		}
		write_sector(start_sector+i,_write_buffer);
	}
}


void init_node_section(FSU32 start_sector,FSU32 node_block,FSU32 total_data_sector)		//初始化节点信息表。
{
	FSU32 i=0;
	PNODE_INFO ptr;

	for(i=0;i<NODE_PER_SECTOR;i++)
	{
		ptr=(PNODE_INFO)(&_write_buffer[i*NODE_INFO_SIZE]);
		ptr->used=0;
	}

	for(i=0;i<node_block;i++)
	{
		write_sector(start_sector+i,_write_buffer);
	}

	ptr=(PNODE_INFO)_write_buffer;
	ptr->used=1;
	ptr->file_amount=0;

	write_sector(start_sector,_write_buffer);
}


